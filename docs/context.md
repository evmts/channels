Prior Art and Context for Event‑Sourced State Channels
State Channel Protocols and Frameworks
Nitro (Force-Move State Channels). Nitro is an Ethereum state channel framework (by the Magmo/Statechannels team) that generalizes payment channels to arbitrary state updates[1]. Nitro introduced ledger channels and virtual channels – ledger channels allow on-chain deposits that fund off-chain channels, and virtual channels allow two parties to open a channel through intermediaries without new on-chain transactions[2]. Nitro decouples channel operation from the network, so each channel can progress independently[3]. It uses the Force-Move game: if a participant stops cooperating, others can initiate an on-chain challenge to force resolution[4]. The on-chain contracts (the Nitro Protocol) enforce that state updates (game moves, app actions, etc.) are signed by all parties and include a turn number. A non-responding or malicious party can be “force-moved” by presenting the latest signed state on-chain and waiting out a timeout; if the counterparty cannot produce a newer valid state, the presented state becomes final. The Go implementation go-nitro provides an off-chain node that manages keys and state, signs updates, monitors chain events, and safely handles funds during join/exit[5][6]. In short, Nitro channels achieve near-instant, zero-fee updates by unanimous off-chain consensus, with an on-chain adjudicator as a backstop for disputes.
Perun. Perun is an academically-developed state channel framework that is blockchain-agnostic and supports multi-party channels and multi-hop networks. The Perun protocols allow users to execute arbitrary smart contract logic off-chain among n participants, with security backed by the blockchain[7][8]. Notably, Perun’s research introduced the first full specification of general state channel networks (CCS 2018) and protocols for virtual payment channel hubs (IEEE S&P 2019) and multi-party virtual channels (Eurocrypt 2019)[8][9]. These innovations allow complex off-chain contracts and payments through intermediary nodes with constant-time dispute resolution even as the channel network grows. Like Nitro, Perun uses on-chain adjudicators and timeouts to ensure any party can settle on-chain if others misbehave, but it focuses on formal verification and blockchain-agnostic design (with an implementation in Go called go-perun[10]).
Counterfactual (Connext). Counterfactual is a generalized state channels framework that pioneered the concept of “counterfactual instantiation” – the idea that contracts and app logic can be treated as if they were deployed on-chain, even though they exist only off-chain[11][12]. In Counterfactual, the only on-chain component needed for a channel is a single multisig wallet contract holding the assets[13]. Participants can off-chain “install” new applications (games, trades, etc.) into an existing channel without any on-chain transactions, by signing commitments that would deploy and execute a contract’s logic if submitted on-chain[13][12]. This means, for example, two users with a channel can play a game or trade tokens by swapping signed state updates, and if a dispute arises, a predetermined on-chain App Definition contract can be called to adjudicate the final state. Counterfactual greatly minimized on-chain operations (e.g. no new contract per app, no on-chain open/close for each game) and preserved privacy (the channel’s multisig looks like an ordinary multisig on-chain, with app interactions happening off-chain)[14]. This framework, which underpinned early Connext and StateChannels work, demonstrated that multiple apps and even upgrades can run through one channel with zero on-chain overhead in the happy case.
Raiden Network. Raiden is an off-chain payment channel network on Ethereum, focused on simple ERC20 token transfers (analogous to Bitcoin’s Lightning Network). Raiden allows parties to lock tokens in a channel smart contract and then transact via signed off-chain messages, achieving near-instant, low-fee payments[15]. Raiden channels can be connected across a network of nodes to route payments (using hashed time-lock contracts for atomic routing). While Raiden doesn’t support arbitrary contract state, it was one of the first production implementations of state channels on Ethereum (besides early projects like SpankChain) and showed that significant throughput improvements are possible for token transfers. It’s a specialized but important piece of prior art for high-frequency off-chain transactions, and many principles (deposit contracts, sequence numbers, timeouts, watchtowers for offline users, etc.) overlap with generalized state channels.
Optimistic Rollups and Interactive Fraud Proofs
Arbitrum Nitro (WASM-based rollup). Arbitrum Nitro is Offchain Labs’ latest Optimistic Rollup architecture, notable for replacing Arbitrum’s custom AVM with a WASM-based fraud proof system. At its core is a new prover that can perform Arbitrum’s classic interactive fraud proofs on WebAssembly code[16]. In practice, Arbitrum’s Layer-2 engine is compiled twice – once to native code for normal fast execution, and once to WebAssembly for verification. The entire Arbitrum state transition function (which is essentially the Ethereum EVM execution, plus ArbOS L2 glue) is compiled to WASM. If a dispute arises, Arbitrum enters an interactive bisection game on the sequence of VM steps: it finds a single step of execution (a specific WASM instruction) that Alice and Bob disagree on. That step is then adjudicated on-chain by executing the one WASM instruction in an on-chain WASM interpreter (the Arbitrum fraud-proof VM). To make on-chain WASM execution tractable in Solidity, Arbitrum uses a custom WASM subset called WAVM. WAVM is a restricted WebAssembly: it strips out floating-point ops (replacing them with software floats) and forbids non-deterministic or variable-time features, flattening control flow and ensuring each instruction’s cost is predictable[17]. It also adds a few custom opcodes for things like reading preimages (to efficiently look up Merkle trie nodes or block hashes by hash) in order to prove Ethereum state accesses[18][19]. In normal operation, Arbitrum’s L2 nodes run the code natively (it even embeds the standard Go-Ethereum engine, “geth”, as a library) and only fall back to WASM if a proof is needed[20]. Security-wise, Arbitrum’s optimistic model requires validators to put down a stake and gives a window (typically ~1 week) for anyone to challenge a posted L2 result. If a fraudulent result is challenged, the interactive protocol identifies the bad step and the on-chain contract (OneStepProof for WASM) checks it. The liar’s stake is slashed – a portion awarded to the honest challenger, and some burned to ensure a penalty even if there’s collusion[21]. This makes cheating economically irrational in theory, leading to the optimistic case where disputes are rare. Arbitrum Nitro’s approach demonstrated that using a general-purpose VM (WASM) for fraud proofs can greatly simplify development (leveraging standard compilers and tools) while maintaining security, since one only pays the gas to verify a single step on-chain rather than the whole transaction.
Optimism Cannon (MIPS-based rollup). Optimism’s Cannon is another interactive fault proof system, but instead of WASM it uses a simplified RISC architecture (MIPS) as the basis for one-step proofs. Cannon compiles the Optimistic rollup’s execution code (essentially a variant of geth or state transition function called OP-Program) into a MIPS binary. Off-chain, an engine called MIPS-EVM (written in Go) can run the MIPS code and produce a trace of each MIPS instruction executed[22]. In a dispute, Optimism’s protocol bisects the execution trace until a single MIPS instruction is pinpointed as disputed. On-chain, a contract called MIPS.sol then emulates that one MIPS instruction and checks that it transforms the machine state correctly[23]. This design effectively lets Ethereum L1 run an entire Ethereum L2 inside a MIPS emulator, one step at a time. The Cannon system was originally implemented by geohot and uses an on-chain interpreter for a subset of MIPS ISA[24]. Off-chain, the fault prover (OP-Challenger) uses the Go MIPS emulator to generate state hashes for each step and a witness of the CPU state (registers, memory merkle proofs, etc.) for the disputed step[25]. By verifying one MIPS instruction, the chain proves the correctness of the entire L2 transaction. Like Arbitrum, Optimism requires a bond from the party asserting a L2 block; a challenger can force the fault proof game if they disagree. One unique aspect of Optimism’s latest design is a multi-proof architecture in development, which could allow multiple claims to be challenged in parallel or alternative VMs to be plugged in[26][27]. (As of 2025, Optimism’s fault proofs were on testnet or not yet regularly triggered on mainnet[28].) Nonetheless, Cannon provides a working example of an EVM-equivalent fault proof: it proves Ethereum execution by compiling Ethereum’s code to a known CPU architecture and methodically checking CPU instructions on-chain. The tradeoff between Cannon and Arbitrum’s WASM approach highlights the design space for interactive proofs – any deterministic VM can be used, be it a stack-based WASM or a RISC CPU – as long as clients can run it off-chain and L1 can efficiently verify a single step.
Truebit (Interactive Compute Off-chain, 2017). Truebit is a historical precursor to modern fraud-proof systems. It’s not a rollup but a protocol for outsourcing computations from Ethereum smart contracts and then verifying the results via a dispute game. In Truebit, a contract (task giver) posts a computational task (in C++ or WebAssembly, for example). A solver provides an off-chain result along with a commitment to a computation trace. A verifier can challenge if they suspect the result is wrong. Solver and verifier then engage in an interactive verification game, binary-searching through the computation steps to find a specific step where they differ[29]. Finally, that step is executed on-chain in the Truebit VM (a minimal VM that can emulate the instruction set used) to determine the truth. Truebit introduced the “verification game” concept and a financial incentive layer: solvers and verifiers put deposits and get rewards or slashed depending on honesty[30]. It was one of the first systems to use off-chain computation with on-chain fraud proofs in Ethereum (predating rollups). However, Truebit in practice faced some complexity (liveness assumptions and economic incentives to have at least one honest verifier for each task). Modern rollups integrated this verification game concept directly into the consensus protocol of the rollup, with the rollup validators serving as solvers/verifiers. Truebit remains important prior art demonstrating that you can securely execute arbitrary computations off-chain and only incur on-chain cost proportional to the length of the dispute (O(log n) steps checked, plus O(1) for the final step) rather than the whole computation.
Zero-Knowledge and Recursion Approaches
While Optimistic rollups rely on interactive fraud proofs, zero-knowledge proof systems take a different approach: proving validity of a batch of computations without interaction, usually producing a succinct proof that is verified on-chain. This is a huge field, but a few points of context:
Mina Protocol (recursive zkSNARKs): Mina (formerly Coda) is a blockchain that uses recursive zk-SNARKs to keep the chain’s state size tiny (a few kilobytes). Every new block comes with a SNARK proving that it and the prior proof chain are valid, recursively compressing the entire chain’s history. Mina’s tech (and its Snarky/O(1) Labs team) also created O(1.js), now called o1js, a framework for writing recursive SNARK provers in JS/TS. The idea of continually composing proofs so that one proof attests to many steps (aka proof recursion) is in stark contrast to interactive proofs: it achieves verifiability in one shot, but usually at the cost of much heavier computation to generate the proofs (minutes of CPU or specialized hardware).
RISC Zero and SP1 (ZK Virtual Machines): Both RISC Zero and Succinct’s SP1 are recent open-source zkVM projects that allow arbitrary code (written for a RISC-V architecture, in these cases) to be proven in a zero-knowledge manner with support for recursion. RISC Zero provides a STARK-based proof system for a RISC-V CPU and supports recursion (“proof composition”) so that large programs can be broken into smaller segments and proven hierarchically. Succinct’s SP1 similarly is a performant zkVM using Plonky2/Plonky3 proving systems. Both aim to scale to very large computations by recursive layering of proofs[31]. In essence, they can produce a succinct proof that “program X executed with input Y produces output Z” and even nest such proofs inside others. The relevance here is that instead of interactive dispute, one could prove an off-chain state transition and post the proof on-chain (validity rollup style). However, today these proofs are far more expensive to generate per step than the simple interactive approach – the PRD explicitly notes avoiding “expensive per-step ZK” in favor of interactive proofs. Projects like RISC Zero and SP1 indicate that over time, proving VMs might get fast enough to consider, or even be used to compress many steps of an interactive protocol into one proof (e.g. a zk proof that a hundred steps of the state channel reducer were executed correctly, which could then be used in a bulk verification on-chain).
zkWASM and zkEVM: There are also efforts to create zero-knowledge proof systems specifically for WASM and EVM execution. zkWASM refers to proving correctness of WebAssembly programs (several teams, like Delphinus, have zkWASM projects for verifying smart contract logic compiled to WASM). zkEVM refers to various projects implementing Ethereum-compatible VMs with ZK proofs (e.g. Scroll, Polygon zkEVM, StarkWare’s Cairo (not EVM but analogous), etc.). These systems generate validity proofs of each transaction or batch of transactions, so that no fraudulent state can ever be posted (there’s no concept of a challenge window – invalid states are provably impossible to accept). StarkNet’s approach, using the Cairo language and STARK proofs, is one example: they designed a new VM (Cairo) that is tailored for efficient proving on STARKs, and the prover generates a proof for each block. These ZK systems provide strong security (instant finality when proof is accepted) and often better capital efficiency (no bonds or challenge periods). The downside is current performance: proving a complex computation (like a high-throughput game or an SQL engine step) could be orders of magnitude slower or more costly than just executing it. That’s why the PRD’s approach sticks to interactive fraud proofs – but it keeps an eye on these ZK solutions as “future compression” or optional enhancements (e.g. one open question is using recursive proofs to batch many reducer steps into one proof, Mina-style, for efficiency later on).
In summary, the landscape of validity proofs (ZK-SNARKs, STARKs, zkVMs) is complementary prior art – offering alternative ways to achieve provable off-chain execution. They inform the design by highlighting what a “deterministic VM” needs (e.g. determinism, bounded memory) and how state commitments can be used (Merkle roots, etc.), even if the chosen approach here is interactive rather than fully zk.
Deterministic WebAssembly and EVM-in-WASM
A core concept in the product is running application logic in a deterministic WASM reducer. Ensuring determinism and provability in a WASM environment has prior art:
Deterministic WASM Profiles: WebAssembly as a spec is mostly deterministic by design (no unbounded variability in execution, no access to real time or randomness unless provided, etc.), but some features can be problematic. For example, floating-point math can yield different results on different hardware if not handled carefully. Projects like Arbitrum’s WAVM explicitly removed floating-point instructions, replacing them with a fixed library (SoftFloat) so that every platform gets identical results[32]. They also disallowed multi-threading, non-deterministic system calls, and even constrained control-flow constructs to fixed-cost patterns[17]. Similarly, any host calls (external functions) are forbidden or strictly regulated in a deterministic WASM module. The design in the PRD follows these lessons: the reducer will allow no nondeterministic behavior (no time, random, or IO) and must run in a sandbox with fixed resources. Essentially, the WASM reducer should behave like a pure function: given the previous state and a new message, it produces a new state, with no external side effects. This determinism is what allows multiple parties to exactly agree on state outcomes and enables a single-step proof to convince a blockchain of a correct vs incorrect transition.
EVM-in-WASM Implementations: Running one virtual machine inside another is a known technique for portability and determinism. Here, the optional Phase 4 of the roadmap mentions “Solidity reducers via EVM-in-WASM,” specifically referencing Guillotine. Guillotine is a new high-performance Ethereum Virtual Machine implementation written in Zig, designed to be ultra-fast and ultra-portable. Early benchmarks show Guillotine can compile down to a WASM binary as small as 110 KB (with optimizations)[33], significantly smaller than other EVM implementations. Despite its small size, it aims to be one of the fastest EVM interpreters. Guillotine achieves this with a data-oriented design, aggressive optimizations (like precomputing jump destinations, using direct threaded code for opcodes, etc.), and by stripping the implementation down to only what’s needed to execute EVM bytecode[34][35]. The idea of integrating something like Guillotine is that one could support Solidity-based state channel apps: the Solidity code would be compiled to EVM bytecode, and then the Guillotine EVM (compiled to WASM) would act as the reducer to interpret that bytecode deterministically off-chain. Prior art for EVM-in-WASM also includes projects like evmone (a C++ EVM by the Ethereum Foundation team) and SputnikVM (a Rust EVM from Parity) which could, in theory, be compiled to WASM for execution in a browser or sandbox. In Ethereum 2.0’s early plans, an eWASM project considered replacing the EVM with WebAssembly for on-chain execution; while that specific plan changed, it led to tools and learnings for executing EVM semantics in a WASM environment[36]. All of this prior work suggests it’s feasible to run blockchain logic inside WASM with high performance. The main challenges are ensuring strict determinism (e.g. gas calculation must be consistent and not dependent on host) and handling the vast opcode set of EVM safely. Guillotine’s approach of an interpreter with no external dependencies, plus the fact it’s written in a modern safe systems language (Zig), makes it a strong candidate for this use-case.
In short, by leveraging deterministic WASM and even layering an EVM interpreter inside WASM, the system can support arbitrary app logic. Whether the app is written as custom WASM (AssemblyScript/Rust compiled to WASM) or as a Solidity smart contract (requiring an EVM-in-WASM), prior art indicates both paths are viable. Projects like evmone-wasm or guillotine prove out the performance and minimal overhead of such an approach, while Arbitrum’s WAVM proves out the security/determinism side on a large scale.
Event Sourcing, Embedded SQL, and Local-First Sync
The product’s approach to state management is inspired by event sourcing and local-first application design:
Event Sourcing and CQRS: In traditional event sourcing, instead of storing the latest state, a system stores an append-only log of events (state transitions). The current state can always be derived by replaying these events from the start (or from the last checkpoint). This provides a full audit log and makes the system deterministic: given the same event log, any replica can compute the same final state. The PRD’s channels adopt this model: the shared source of truth between parties is the log of messages (m_1..m_i), and the database state is a derived view. This is analogous to Command Query Responsibility Segregation (CQRS) where commands (events) are separate from query models (here, the embedded SQL database). Prior art for event-sourced architectures in crypto includes earlier state channel systems that used logs of updates and snapshotting, as well as some blockchain designs (Ethereum’s history is somewhat an event log of transactions, though not replayed in user space). The key benefit is consistency and ease of conflict resolution: if two peers’ logs diverge, you have a clear definition of which messages exist or not. The channel protocol will enforce that messages are appended in order and agreed/signed, so the log cannot fork without blatant misbehavior.
Embedded SQL (PGlite) for Materialized State: A novel part of the design is using a PostgreSQL-compatible engine compiled to WASM (called PGlite) to hold and query the state. Prior art here comes from the local-first database community. PGlite itself is an open-source project by ElectricSQL that compiles the Postgres 15 codebase to WebAssembly, enabling a full SQL server in the browser or other WASM environments[37]. Remarkably, PGlite is not a partial reimplementation – it’s a “fully-featured PostgreSQL server” running in WASM, supporting many extensions and features of Postgres[37]. ElectricSQL uses this to give web apps an offline-capable Postgres instance that syncs with a cloud database. The PRD proposes to leverage PGlite in the state channel context: the deterministic reducer function would apply events to this embedded database (via SQL writes or via a programmatic interface), and then the resulting DB state is snapshotted. By Merkleizing the storage pages or rows, one can get a db_root hash that commits to the entire contents of the embedded database. This approach is inspired by systems like Facebook’s Apollo (which did something similar with SQLite in mobile), and ElectricSQL’s approach to use CRDTs under the hood of a SQL database. Using SQL as the state model allows rich queries (for read models or for off-chain verification/auditing) that pure key-value Merkle trees make difficult. It’s worth noting that querying in a dispute context might be limited (disputes likely focus on the deterministic state transitions), but off-chain it’s a huge developer boon: one can write app logic that says “INSERT row” or “SELECT with JOIN” and it just works locally on each participant’s machine, with the guarantee that the same queries on the same event log produce the same answers everywhere.
Local-First Sync Systems: The product vision (“local-first apps with durable sync”) aligns with a lot of recent work like ElectricSQL and Replicache. ElectricSQL’s system, for example, keeps a local Postgres (PGlite) or SQLite on the client that is automatically synchronized with a central Postgres. It uses CRDTs and logical replication to merge changes from multiple clients. One of Electric’s selling points is that it provides Transactional Causal Consistency via CRDTs – meaning no matter how clients go offline and diverge, when they sync, all operations will be applied in a consistent order without conflicts (CRDTs resolve conflicts by design)[38]. They also emphasize “finality of local writes”, i.e. once a user’s action is saved locally, it will never be rejected or lost – it will always be incorporated into the eventual state (though possibly modified by CRDT merge semantics)[39]. Our state channel scenario is simpler (two parties rather than arbitrary clients, and both must sign each event), so we don’t need CRDT conflict resolution – there is a total order of events by construction. However, the spirit is similar: each user can act instantly on their local copy, update the state, and see the result immediately, trusting that the sync (through the state channel protocol) will eventually deliver that event to the other and reach consistency. Replicache, on the other hand, is a client-side library that gives you a persistent key-value store (often backed by IndexedDB) and syncs with a backend via a pull/push mechanism. It lets the UI do optimistic updates – apply writes locally and sync in the background – so the UX is always snappy[40]. If conflicts arise (two clients updated the same record), the default in Replicache is a server-side “reconciliation” function that merges changes in an application-specific way[41] (often last-writer-wins or a custom merge). The takeaway from Replicache is the pattern of optimistic UI and background sync, which is exactly what state channels enable (immediate local state update, then network sync with peer and eventual consistency). Where a product like Replicache has to trust a server to do merging, our state channels ensure that both peers agree on every state update (or they trigger a dispute). In effect, state channels provide an even stronger consistency model (no divergent forks unless someone is outright malicious, which then triggers dispute resolution).
CRDTs and Conflict-free Replication: Although CRDTs might not be directly used in a two-party channel (since the two parties handshake on each event), the philosophy of conflict-free replicated data types influences the design of local-first systems. CRDTs guarantee that, if two replicas apply a set of updates (even in different orders), they converge to the same state, without needing centralized arbitration. In our case, the “protocol” ensures the two replicas apply events in the same order (the order of the log), so it’s trivially convergent. However, if we consider spectators or third-party syncing (Open Question 5 in the PRD mentions “spectator feeds: db deltas vs raw messages”), we might broadcast events to many replicas that aren’t actively signing. In that case, using CRDT-like approaches or at least well-defined merges for read-only replicas could be useful. The references to CRDT literature in prior art (e.g. Martin Kleppmann’s work, Automerge, etc.) remind us that there is a rich theory on making state convergence automatic. Our context is simpler due to strong consistency between two main parties, but if expanding to multi-writer or more decentralized syncing, CRDT principles might come in.
In summary, the product’s use of an event log + deterministic reducer + embedded database draws from decades of database and distributed systems research. It combines the strong consistency and provability of blockchain/state channels with the usability and performance of local-first apps. Prior systems like ElectricSQL and Replicache validate the developer demand for instant, offline-capable apps, and show that with the right sync protocol and data structures, we can maintain consistency and integrity. Our approach differs by having cryptographic security and on-chain dispute resolution – a step beyond typical local-first systems which assume honest clients and use eventual server reconciliation. It’s like taking the best of both: CRDTs/Local-first for UX, and state channels/rollups for trustlessness.
Security Considerations in Prior Implementations
Every system we’ve discussed had to carefully design for security and integrity, which informs our design too:
State Channel Security: In frameworks like Nitro, Counterfactual, and Perun, the fundamental security is that no one can steal funds or force an incorrect state without the other party’s signature. Each off-chain state update is signed by all participants. The on-chain adjudicator contracts (e.g. Nitro’s ForceMove contract) will only accept a state if it has the appropriate signatures and is an allowed progression from the previous state (often enforced by an app-specific validation on-chain). There is typically a challenge period: if Alice unilaterally submits a state to close the channel, Bob has e.g. 7 days to respond with a newer state if one exists. This guarantees that even if Alice tries to finalize an old state where she had more money, Bob can always prove a later state supersedes it. As long as one honest party remains live to respond on-chain, the channel is secure (liveness is important – hence watchtower services can be used if a user goes offline). In Nitro’s case, they reported goals of “<1% disputes; zero loss of funds” – meaning ideally disputes rarely happen, but if they do the protocol ensures the honest party doesn’t lose money.
Rollup Security (Optimistic): As noted, optimistic rollups like Arbitrum/Optimism rely on economic incentives. They require any party posting a result to lock a bond. If someone posts a fraudulent state root or transition, an honest party can challenge and prove fraud, earning a reward and slashing the bad actor[21]. This relies on at least one honest verifier monitoring (in practice, many watchers do). The security is only as good as the fraud proof mechanism – which is why so much care is put into the one-step provers. They must accurately model the off-chain execution environment. For instance, Arbitrum’s floating-point removal was to ensure no discrepancy between different machines that could be exploited[17]. Both Arbitrum and Optimism also had extensive audits and formal reasoning about their custom VMs (Arbitrum published a formal spec for AVM and Nitro; Optimism’s MIPS approach leverages the well-understood MIPS architecture and they test equivalence between the high-level and compiled code extensively). One subtle security consideration is data availability: fraud proofs assume the honest party can access the full data (transactions, etc.) needed to recompute the state. Arbitrum posts all transactions on L1 (call data) to ensure this[42]. In state channels, data availability is simpler (each participant has the data by definition, since they co-produced the log), but if we consider spectators, we’d ensure they have the log or at least the final state and a proof.
Code Hash Pinning: Many systems pin the exact code that will be executed off-chain by including a hash on-chain. Counterfactual’s commitments included the hash of the app definition contract; Nitro includes the appDefinition (or a reducerId) in the channel setup. Our design similarly uses reducerId = H(WASM code + VM profile) in the channel’s fixed parameters. This ensures that during a dispute, the on-chain verifier knows what code to run (or what code hash to verify against) – a participant can’t swap out the reducer logic for a malicious version mid-way. Guillotine or PGlite versions would likely also be identified by hashes or version IDs to guard against any differences.
Merkleization and Witnesses: Any time a system proves a step of a computation that involves large state (like memory or a database), it uses Merkle trees and Merkle proofs. Arbitrum stores the VM memory and register state in a Merkle tree and provides a Merkle proof as part of the one-step proof so the contract can verify only the touched parts. Likewise, a Merkle root of the PGlite database will be maintained so that disputes don’t pass around the whole DB – they just pass a root hash. If a dispute goes to a one-step proof, the proof will contain the Merkle proof of any database row or page that was read/modified by that event. This is similar to Arbitrum’s use of the ReadPreImage opcode and keeping only a root hash of the state tree in the VM state[19]. Security here relies on cryptographic hash collision resistance: an attacker cannot fake a Merkle proof for a wrong state without being caught.
Resource Limits and DOS Protection: For on-chain execution of one-step proofs, the operation must be bounded in gas. Arbitrum’s WAVM and Optimism’s MIPS are both designed to have a fixed cost per step, so that verifying one step is affordable (on an L2, a target might be 1–2 million gas for the worst-case step). They also structure the dispute as a binary search so that at most O(log n) on-chain steps are executed for a dispute of n steps. In our channels, we similarly need to ensure the reducer is not doing unbounded work per message. That’s why the PRD includes a “fuel” or step budget per message. The WASM reducer can be instrumented to count instructions or have explicit gas, and refuse to execute beyond a limit (yielding an error). This prevents a denial-of-service where a malicious message triggers an infinite loop or extremely heavy computation. The state channel protocol could define that such an error (exceeding budget) is a provable fault (the party who sent the message that caused it loses the dispute by default, for example).
Interactive vs Finality tradeoff: One acknowledged risk of optimistic systems is the time window where a fraud could go unchallenged (for rollups, the challenge period; for channels, the time before a timeout expires). In that window, users might assume something is final when it’s not. Prior art mitigations include a robust watchtower ecosystem – services that will, for a fee or reward, watch the chain or channel for you and submit challenges if needed. In Lightning/Raiden, users can give their latest state to a watchtower to ensure a cheating counterparty can’t quietly close an old state. In rollups, anyone can be a watcher since data is public, and the economic incentives (the slashing reward) motivate it. Our design will likewise rely on the parties (or their chosen services) to be actively watching for disputes. The goal of “<1% disputes” suggests we expect most channels to close cooperatively or at least without foul play. Nonetheless, the system design must handle that 1% gracefully.
Zero Loss of Funds: Ultimately, all these systems guarantee that if protocols are followed, no honest participant loses funds. In channels, the worst that can happen if you’re offline too long is you might fail to challenge and an old state is finalized – hence best practice is to always have some form of backup online. In rollups, users typically rely on a decentralized set of validators to challenge invalid blocks (it’s a more shared security model). Our state channels will have two-party security: as long as you or a designated guardian is monitoring, your funds are safe under all circumstances by design.
Prior Exploits and Lessons: It’s worth noting that earlier implementations had some bugs – e.g., early versions of the Counterfactual hub had to consider wallet contract nonce management to avoid races, some Lightning implementations had corner-case failures in penalty transactions, etc. The lesson is to keep the on-chain contracts as simple as possible (ideally just enforcing signatures, sequence, and calling into a simple WASM verifier). By using a single-VM-step verification, we minimize the surface (we don’t reimplement the entire app on-chain, just the VM step logic). That reduces complexity versus older state channels where each app might have a custom on-chain validation function (room for error). Still, formal verification of the WASM execution semantics or extensive fuzz testing (as mentioned in PRD “adversarial test corpus”) will be crucial to avoid any mismatch between off-chain and on-chain execution.
In conclusion, the rich prior art from state channels and rollups provides a blueprint for a secure design: ensure determinism, pin the code, commit to state with hashes, require unanimous agreement off-chain and allow unilateral proof on-chain, incentivize honesty, and guard against resource attacks. By following these principles, the system can achieve the PRD’s vision of trustless, high-speed local execution with on-chain enforceability, standing on the shoulders of those earlier innovations.
References & Prior Art
State Channels (Force-Move): Nitro Protocol by Magmo (2019) – introduced ledger/virtual channels[1][2]. Perun – academic state channels with multi-party support (CCS 2018 etc.)[8]. Counterfactual (Connext) – generalized channel framework with counterfactual instantiation[13][12]. Raiden Network – Ethereum payment channel network for ERC20 tokens[15].
Interactive Fraud Proofs: Truebit protocol – pioneered interactive verification games on Ethereum[29]. Arbitrum (Nitro) – Optimistic rollup using WASM (WAVM) one-step proofs[16][17]. Optimism (Cannon) – Optimistic rollup using MIPS one-step proofs[24][23]. Also related, Arbitrum Classic and Arbitrum Nitro preview blogs which highlighted moving from a custom VM to WASM[16], and Optimism Bedrock which implements Cannon.
ZK and Validity Proofs: Mina Protocol – uses recursive zkSNARKs for a succinct blockchain. StarkNet (Cairo) – a ZK-rollup with a custom VM proven with STARKs. RISC Zero – general-purpose zkVM using RISC-V + STARKs with recursion[31]. Succinct’s SP1 – high-performance open-source zkVM (Plonky3)[31]. zkEVM projects (Polygon zkEVM, Scroll, zKEVM by zkSync) – EVM-compatible SNARK rollups. zkWASM projects – e.g. Delphinus’ zkWASM, proving WASM code execution. These are referenced as contrasts or future paths (for compressing many steps into one proof).
Deterministic WASM & VMs: WebAssembly determinism – E.g. Arbitrum’s WAVM spec (no floats, fixed gas)[17]. Ethereum’s eWASM research (resulted in Eth “phase2” proposals, evm2.0 design discussions). EVM implementations: evmone (C++ EVM by EF’s Martin Swende et al.) – known for speed; SputnikVM (Rust, used in Parity) – was designed for embedability; Guillotine EVM – new Zig-based EVM, very small WASM build (110KB) and fast[33]. Also the concept of running EVM inside WASM was explored in some Ethereum 1.x research as a way to implement the EVM as a precompile.
Event Sourcing and Local-First: Event sourcing in databases – Martin Kleppmann’s work (Log DB, etc.), Greg Young’s CQRS pattern. ElectricSQL – local-first Postgres with CRDT sync (introduced PGlite, 2023)[37]. PGlite – PostgreSQL compiled to WASM, used for offline persistence in browser[37]. Replicache by Rochicorp – client-side database with background sync and server reconciliation for conflicts[40][41]. Automerge and CRDT research (Cambridge, INRIA) – techniques for conflict-free merges that influence systems like Electric. Realm and Firebase (earlier mobile sync solutions) – showed developer demand for realtime sync, though not conflict-free by default.
All these pieces contribute context and validation for the Event-Sourced State Channels approach. By combining ideas from them – state channels for trustless off-chain execution, rollup-style fraud proofs for scalability, deterministic WASM for a universal execution sandbox, SQL/CRDT-powered local state for rich functionality, etc. – we aim to build a system that delivers high throughput and a great developer experience without sacrificing security or decentralization[16][6]. The prior art suggests each of these components is feasible; the innovation will be in synthesizing them into a coherent protocol and developer framework. With 10+ years of research and engineering to draw on, this product stands on a strong foundation. The goal now is to execute and iterate, using these references as guideposts for what to do (and what pitfalls to avoid) in realizing the vision of local-first, provably-correct state channels.

[1] [2] [3] [4] Nitro Protocol. Today we’re excited to release Nitro… | by Tom Close | Magmo | Medium
https://medium.com/magmo/nitro-protocol-c49b50f59df7
[5] [6] Nitro Protocol Documentation
https://docs.statechannels.org/
[7] [8] [9] Technology - Perun
https://perun.network/technology/
[10] Perun's Blockchain-Agnostic State Channels Framework in Go.
https://github.com/hyperledger-labs/go-perun
[11] [12] [13] [14] Counterfactual: Generalized State Channels on Ethereum | by Liam Horne | State Channels | Medium
https://medium.com/statechannels/counterfactual-generalized-state-channels-on-ethereum-d38a36d25fc6
[15] Raiden Network
https://raiden.network/
[16] [20] GitHub - OffchainLabs/nitro: Nitro goes vroom and fixes everything
https://github.com/OffchainLabs/nitro
[17] [18] [19] [21] [32] [42] Inside Arbitrum Nitro | Hyra Network | Docs
https://docs.hyra.network/docs/development_documentation/how-arbitrum-works/inside-arbitrum-nitro/
[22] [23] [25] Fault proof VM: Cannon - Optimism Documentation
https://docs.optimism.io/concepts/architecture/fault-proofs/cannon
[24] GitHub - ethereum-optimism/cannon: On chain interactive fault prover for Ethereum
https://github.com/ethereum-optimism/cannon
[26] From Zero to Hero: OP Stack Fault Proof Series 1 [ENG] - Medium
https://medium.com/tokamak-network/the-feature-complete-version-of-op-stack-fault-proofs-series-1-eng-f2e057af7209
[27] A closer look at OP Stack and Optimism's Superchain | OAK Research
https://oakresearch.io/en/reports/protocols/a-closer-look-at-op-stack-optimism-superchain
[28] Arbitrum vs Optimism - Blockworks Research
https://app.blockworksresearch.com/unlocked/arbitrum-vs-optimism
[29] [PDF] A scalable verification solution for blockchains - Full-Time Faculty
https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf
[30] Home - Truebit - Don't just trust, verify
https://truebit.io/
[31] Comparative Analysis of SP1 and RISC Zero Zero-Knowledge ...
https://medium.com/@gwrx2005/comparative-analysis-of-sp1-and-risc-zero-zero-knowledge-virtual-machines-4abf806daa70
[33] [34] [35] Thread by @tevmtools on Thread Reader App – Thread Reader App
https://threadreaderapp.com/thread/1965660639990554881
[36] ipsilon/evmone: Fast Ethereum Virtual Machine implementation
https://github.com/ipsilon/evmone
[37] Running PostgreSQL in the Browser with PGlite | by Tihomir Manushev | Medium
https://medium.com/@tihomir.manushev/running-postgresql-in-the-browser-with-pglite-64b3e14cb8d8
[38] [39] ElectricSQL, PGLite, CRDTs, and Elixir with James Arthur
https://materializedview.io/p/electricsql-pglite-crdts-and-elixir
[40] [41] Replicache
https://replicache.dev/
